{"ast":null,"code":"import { Rect as $gtW1T$Rect, LayoutInfo as $gtW1T$LayoutInfo, Size as $gtW1T$Size, Layout as $gtW1T$Layout } from \"@react-stately/virtualizer\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $61ef60fc9b1041f4$exports = {};\n$parcel$export($61ef60fc9b1041f4$exports, \"ListLayout\", () => $61ef60fc9b1041f4$export$cacbb3924155d68e);\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\n\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends $gtW1T$Layout {\n  getLayoutInfo(key) {\n    return this.layoutInfos.get(key);\n  }\n\n  getVisibleLayoutInfos(rect) {\n    let res = [];\n\n    let addNodes = nodes => {\n      for (let node of nodes) if (this.isVisible(node, rect)) {\n        res.push(node.layoutInfo);\n        if (node.header) res.push(node.header);\n        if (node.children) addNodes(node.children);\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node, rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky;\n  }\n\n  validate(invalidationContext) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    this.invalidateEverything = invalidationContext.sizeChanged;\n    this.collection = this.virtualizer.collection;\n    this.rootNodes = this.buildCollection(); // Remove deleted layout nodes\n\n    if (this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) if (!this.collection.getItem(key)) {\n        let layoutNode = this.layoutNodes.get(key);\n\n        if (layoutNode) {\n          var ref;\n          this.layoutInfos.delete(layoutNode.layoutInfo.key);\n          this.layoutInfos.delete((ref = layoutNode.header) === null || ref === void 0 ? void 0 : ref.key);\n          this.layoutNodes.delete(key);\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n  }\n\n  buildCollection() {\n    let y = this.padding;\n    let nodes = [];\n\n    for (let node of this.collection) {\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n    }\n\n    if (this.isLoading) {\n      var _loaderHeight;\n\n      let rect = new $gtW1T$Rect(0, y, this.virtualizer.visibleRect.width, (_loaderHeight = this.loaderHeight) !== null && _loaderHeight !== void 0 ? _loaderHeight : this.virtualizer.visibleRect.height);\n      let loader = new $gtW1T$LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({\n        layoutInfo: loader\n      });\n      y = loader.rect.maxY;\n    }\n\n    if (nodes.length === 0) {\n      var _placeholderHeight;\n\n      let rect = new $gtW1T$Rect(0, y, this.virtualizer.visibleRect.width, (_placeholderHeight = this.placeholderHeight) !== null && _placeholderHeight !== void 0 ? _placeholderHeight : this.virtualizer.visibleRect.height);\n      let placeholder = new $gtW1T$LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({\n        layoutInfo: placeholder\n      });\n      y = placeholder.rect.maxY;\n    }\n\n    this.contentSize = new $gtW1T$Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  buildChild(node, x, y) {\n    let cached = this.layoutNodes.get(node.key);\n    if (!this.invalidateEverything && cached && cached.node === node && y === (cached.header || cached.layoutInfo).rect.y) return cached;\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n\n    var _parentKey;\n\n    layoutNode.layoutInfo.parentKey = (_parentKey = node.parentKey) !== null && _parentKey !== void 0 ? _parentKey : null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n    if (layoutNode.header) this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    let headerRect = new $gtW1T$Rect(0, y, width, rectHeight);\n    let header = new $gtW1T$LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n    let rect = new $gtW1T$Rect(0, y, width, 0);\n    let layoutInfo = new $gtW1T$LayoutInfo(node.type, node.key, rect);\n    let startY = y;\n    let children = [];\n\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n    }\n\n    rect.height = y - startY;\n    return {\n      header: header,\n      layoutInfo: layoutInfo,\n      children: children\n    };\n  }\n\n  buildItem(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    if (typeof this.indentationForItem === 'function') x += this.indentationForItem(this.collection, node.key) || 0;\n    let rect = new $gtW1T$Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new $gtW1T$LayoutInfo(node.type, node.key, rect); // allow overflow so the focus ring/selection ring can extend outside to overlap with the adjacent items borders\n\n    layoutInfo.allowOverflow = true;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo\n    };\n  }\n\n  updateItemSize(key, size) {\n    let layoutInfo = this.layoutInfos.get(key); // If no layoutInfo, item has been deleted/removed.\n\n    if (!layoutInfo) return false;\n    layoutInfo.estimatedSize = false;\n\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo); // Invalidate layout for this layout node and all parents\n\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n      let node = this.collection.getItem(layoutInfo.parentKey);\n\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n    let n = this.layoutNodes.get(key);\n\n    if (n) {\n      // Invalidate by clearing node.\n      n.node = null; // Replace layout info in LayoutNode\n\n      if (n.header === oldLayoutInfo) n.header = newLayoutInfo;else if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key) {\n    let collection = this.collection;\n    key = collection.getKeyBefore(key);\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key) {\n    let collection = this.collection;\n    key = collection.getKeyAfter(key);\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyLeftOf(key) {\n    return key;\n  }\n\n  getKeyRightOf(key) {\n    return key;\n  }\n\n  getKeyPageAbove(key) {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n\n      while (layoutInfo && layoutInfo.rect.y > pageY) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) return layoutInfo.key;\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key) {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) return layoutInfo.key;\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey() {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  } // getDragTarget(point: Point): DragTarget {\n  //   let visible = this.getVisibleLayoutInfos(new Rect(point.x, point.y, 1, 1));\n  //   if (visible.length > 0) {\n  //     visible = visible.sort((a, b) => b.zIndex - a.zIndex);\n  //     return {\n  //       type: 'item',\n  //       key: visible[0].key\n  //     };\n  //   }\n  //   return null;\n  // }\n  // getDropTarget(point: Point): DropTarget {\n  //   let key = this.virtualizer.keyAtPoint(point);\n  //   if (key) {\n  //     return {\n  //       type: 'item',\n  //       key,\n  //       dropPosition: DropPosition.ON\n  //     };\n  //   }\n  //   return null;\n  // }\n\n\n  getInitialLayoutInfo(layoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n  /**\n  * Creates a new ListLayout with options. See the list of properties below for a description\n  * of the options that can be provided.\n  */\n\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.disabledKeys = new Set();\n    this.allowDisabledKeyFocus = false;\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.loaderHeight = options.loaderHeight;\n    this.placeholderHeight = options.placeholderHeight;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;\n  }\n\n}\n\nclass $d0b780b1688f1001$export$7e9c3f5c8fff54f extends $61ef60fc9b1041f4$export$cacbb3924155d68e {\n  buildCollection() {\n    // If columns changed, clear layout cache.\n    if (!this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c, i) => c.key !== this.lastCollection.columns[i].key)) // Invalidate everything in this layout pass. Will be reset in ListLayout on the next pass.\n      this.invalidateEverything = true; // Track whether we were previously loading. This is used to adjust the animations of async loading vs inserts.\n\n    let loadingState = this.collection.body.props.loadingState;\n    this.wasLoading = this.isLoading;\n    this.isLoading = loadingState === 'loading' || loadingState === 'loadingMore';\n    this.buildColumnWidths();\n    let header = this.buildHeader();\n    let body = this.buildBody(0);\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new $gtW1T$Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [header, body];\n  }\n\n  buildColumnWidths() {\n    this.columnWidths = new Map();\n    this.stickyColumnIndices = []; // Pass 1: set widths for all explicitly defined columns.\n\n    let remainingColumns = new Set();\n    let remainingSpace = this.virtualizer.visibleRect.width;\n\n    for (let column of this.collection.columns) {\n      let props = column.props;\n\n      var _width;\n\n      let width = (_width = props.width) !== null && _width !== void 0 ? _width : this.getDefaultWidth(props);\n\n      if (width != null) {\n        let w = this.parseWidth(width);\n        this.columnWidths.set(column.key, w);\n        remainingSpace -= w;\n      } else remainingColumns.add(column); // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n\n\n      if (column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);\n    } // Pass 2: if there are remaining columns, then distribute the remaining space evenly.\n\n\n    if (remainingColumns.size > 0) {\n      let columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n\n      for (let column of remainingColumns) {\n        let props = column.props;\n        let minWidth = props.minWidth != null ? this.parseWidth(props.minWidth) : 75;\n        let maxWidth = props.maxWidth != null ? this.parseWidth(props.maxWidth) : Infinity;\n        let width = Math.floor(Math.max(minWidth, Math.min(maxWidth, columnWidth)));\n        this.columnWidths.set(column.key, width);\n        remainingSpace -= width;\n        if (width !== columnWidth) columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n      }\n    }\n  }\n\n  parseWidth(width) {\n    if (typeof width === 'string') {\n      let match = width.match(/^(\\d+)%$/);\n      if (!match) throw new Error('Only percentages are supported as column widths');\n      return this.virtualizer.visibleRect.width * (parseInt(match[1], 10) / 100);\n    }\n\n    return width;\n  }\n\n  buildHeader() {\n    let rect = new $gtW1T$Rect(0, 0, 0, 0);\n    let layoutInfo = new $gtW1T$LayoutInfo('header', 'header', rect);\n    let y = 0;\n    let width = 0;\n    let children = [];\n\n    for (let headerRow of this.collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y);\n      layoutNode.layoutInfo.parentKey = 'header';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n    this.layoutInfos.set('header', layoutInfo);\n    return {\n      layoutInfo: layoutInfo,\n      children: children\n    };\n  }\n\n  buildHeaderRow(headerRow, x, y) {\n    let rect = new $gtW1T$Rect(0, y, 0, 0);\n    let row = new $gtW1T$LayoutInfo('headerrow', headerRow.key, rect);\n    let height = 0;\n    let columns = [];\n\n    for (let cell of headerRow.childNodes) {\n      let layoutNode = this.buildChild(cell, x, y);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      columns.push(layoutNode);\n    }\n\n    this.setChildHeights(columns, height);\n    rect.height = height;\n    rect.width = x;\n    return {\n      layoutInfo: row,\n      children: columns\n    };\n  }\n\n  setChildHeights(children, height) {\n    for (let child of children) if (child.layoutInfo.rect.height !== height) {\n      // Need to copy the layout info before we mutate it.\n      child.layoutInfo = child.layoutInfo.copy();\n      this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n      child.layoutInfo.rect.height = height;\n    }\n  }\n\n  getColumnWidth(node) {\n    var _colspan;\n\n    let colspan = (_colspan = node.colspan) !== null && _colspan !== void 0 ? _colspan : 1;\n    let width = 0;\n\n    for (let i = 0; i < colspan; i++) {\n      let column = this.collection.columns[node.index + i];\n      width += this.columnWidths.get(column.key);\n    }\n\n    return width;\n  }\n\n  getEstimatedHeight(node, width, height, estimatedHeight) {\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = curNode !== lastNode || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight;\n        isEstimated = true;\n      }\n    }\n\n    return {\n      height: height,\n      isEstimated: isEstimated\n    };\n  }\n\n  buildColumn(node, x, y) {\n    var ref;\n    let width = this.getColumnWidth(node);\n    let {\n      height: height,\n      isEstimated: isEstimated\n    } = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n    let rect = new $gtW1T$Rect(x, y, width, height);\n    let layoutInfo = new $gtW1T$LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = (ref = node.props) === null || ref === void 0 ? void 0 : ref.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo\n    };\n  }\n\n  buildBody(y) {\n    let rect = new $gtW1T$Rect(0, y, 0, 0);\n    let layoutInfo = new $gtW1T$LayoutInfo('rowgroup', 'body', rect);\n    let startY = y;\n    let width = 0;\n    let children = [];\n\n    for (let node of this.collection.body.childNodes) {\n      let layoutNode = this.buildChild(node, 0, y);\n      layoutNode.layoutInfo.parentKey = 'body';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    if (this.isLoading) {\n      let rect = new $gtW1T$Rect(0, y, width || this.virtualizer.visibleRect.width, children.length === 0 ? this.virtualizer.visibleRect.height : 60);\n      let loader = new $gtW1T$LayoutInfo('loader', 'loader', rect);\n      loader.parentKey = 'body';\n      loader.isSticky = children.length === 0;\n      this.layoutInfos.set('loader', loader);\n      children.push({\n        layoutInfo: loader\n      });\n      y = loader.rect.maxY;\n      width = Math.max(width, rect.width);\n    } else if (children.length === 0) {\n      let rect = new $gtW1T$Rect(0, y, this.virtualizer.visibleRect.width, this.virtualizer.visibleRect.height);\n      let empty = new $gtW1T$LayoutInfo('empty', 'empty', rect);\n      empty.parentKey = 'body';\n      empty.isSticky = true;\n      this.layoutInfos.set('empty', empty);\n      children.push({\n        layoutInfo: empty\n      });\n      y = empty.rect.maxY;\n      width = Math.max(width, rect.width);\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n    this.layoutInfos.set('body', layoutInfo);\n    return {\n      layoutInfo: layoutInfo,\n      children: children\n    };\n  }\n\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n\n      case 'item':\n        return this.buildRow(node, x, y);\n\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n\n      case 'cell':\n        return this.buildCell(node, x, y);\n\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  buildRow(node, x, y) {\n    let rect = new $gtW1T$Rect(x, y, 0, 0);\n    let layoutInfo = new $gtW1T$LayoutInfo('row', node.key, rect);\n    let children = [];\n    let height = 0;\n\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      children.push(layoutNode);\n    }\n\n    this.setChildHeights(children, height);\n    rect.width = x;\n    rect.height = height + 1; // +1 for bottom border\n\n    return {\n      layoutInfo: layoutInfo,\n      children: children\n    };\n  }\n\n  buildCell(node, x, y) {\n    var ref;\n    let width = this.getColumnWidth(node);\n    let {\n      height: height,\n      isEstimated: isEstimated\n    } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new $gtW1T$Rect(x, y, width, height);\n    let layoutInfo = new $gtW1T$LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = (ref = node.props) === null || ref === void 0 ? void 0 : ref.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo\n    };\n  }\n\n  getVisibleLayoutInfos(rect) {\n    let res = [];\n\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  addVisibleLayoutInfos(res, node, rect) {\n    if (!node.children || node.children.length === 0) return;\n\n    switch (node.layoutInfo.type) {\n      case 'header':\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n\n        break;\n\n      case 'rowgroup':\n        {\n          let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n          let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n\n          for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n            res.push(node.children[i].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[i], rect);\n          }\n\n          break;\n        }\n\n      case 'headerrow':\n      case 'row':\n        {\n          let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n          let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n          let stickyIndex = 0;\n\n          for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n            // Sticky columns and row headers are always in the DOM. Interleave these\n            // with the visible range so that they are in the right order.\n            if (stickyIndex < this.stickyColumnIndices.length) {\n              let idx = this.stickyColumnIndices[stickyIndex];\n\n              while (idx < i) {\n                res.push(node.children[idx].layoutInfo);\n                idx = this.stickyColumnIndices[stickyIndex++];\n              }\n            }\n\n            res.push(node.children[i].layoutInfo);\n          }\n\n          while (stickyIndex < this.stickyColumnIndices.length) {\n            let idx = this.stickyColumnIndices[stickyIndex++];\n            res.push(node.children[idx].layoutInfo);\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  binarySearch(items, point, axis) {\n    let low = 0;\n    let high = items.length - 1;\n\n    while (low <= high) {\n      let mid = low + high >> 1;\n      let item = items[mid];\n      if (axis === 'x' && item.layoutInfo.rect.maxX < point.x || axis === 'y' && item.layoutInfo.rect.maxY < point.y) low = mid + 1;else if (axis === 'x' && item.layoutInfo.rect.x > point.x || axis === 'y' && item.layoutInfo.rect.y > point.y) high = mid - 1;else return mid;\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n  getInitialLayoutInfo(layoutInfo) {\n    let res = super.getInitialLayoutInfo(layoutInfo); // If this insert was the result of async loading, remove the zoom effect and just keep the fade in.\n\n    if (this.wasLoading) res.transform = null;\n    return res;\n  }\n\n  constructor(options) {\n    super(options);\n    this.wasLoading = false;\n    this.isLoading = false;\n    this.getDefaultWidth = options.getDefaultWidth;\n  }\n\n}\n\nexport { $d0b780b1688f1001$export$7e9c3f5c8fff54f as TableLayout, $61ef60fc9b1041f4$export$cacbb3924155d68e as ListLayout };","map":{"version":3,"mappings":"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","names":["$61ef60fc9b1041f4$var$DEFAULT_HEIGHT","$61ef60fc9b1041f4$export$cacbb3924155d68e","$gtW1T$Layout","getLayoutInfo","key","layoutInfos","get","getVisibleLayoutInfos","rect","res","addNodes","nodes","node","isVisible","push","layoutInfo","header","children","rootNodes","intersects","isSticky","validate","invalidationContext","invalidateEverything","sizeChanged","collection","virtualizer","buildCollection","lastCollection","getKeys","getItem","layoutNode","layoutNodes","ref","delete","lastWidth","visibleRect","width","y","padding","buildChild","maxY","isLoading","_loaderHeight","$gtW1T$Rect","loaderHeight","height","loader","$gtW1T$LayoutInfo","set","length","_placeholderHeight","placeholderHeight","placeholder","contentSize","$gtW1T$Size","x","cached","buildNode","_parentKey","parentKey","type","buildSection","buildItem","rectHeight","headingHeight","isEstimated","previousLayoutNode","curNode","lastNode","estimatedSize","rendered","estimatedHeadingHeight","headerRect","startY","child","childNodes","rowHeight","estimatedRowHeight","indentationForItem","allowOverflow","updateItemSize","size","newLayoutInfo","copy","updateLayoutNode","oldLayoutInfo","n","getContentSize","getKeyAbove","getKeyBefore","item","allowDisabledKeyFocus","disabledKeys","has","getKeyBelow","getKeyAfter","getKeyLeftOf","getKeyRightOf","getKeyPageAbove","pageY","Math","max","keyAbove","getFirstKey","getKeyPageBelow","min","keyBelow","getLastKey","getKeyForSearch","search","fromKey","collator","substring","textValue","slice","compare","getInitialLayoutInfo","opacity","transform","getFinalLayoutInfo","constructor","options","Set","Map","$d0b780b1688f1001$export$7e9c3f5c8fff54f","columns","some","c","i","loadingState","body","props","wasLoading","buildColumnWidths","buildHeader","buildBody","columnWidths","stickyColumnIndices","remainingColumns","remainingSpace","column","_width","getDefaultWidth","w","parseWidth","add","isSelectionCell","rowHeaderColumnKeys","index","columnWidth","minWidth","maxWidth","Infinity","floor","match","Error","parseInt","headerRow","headerRows","buildHeaderRow","row","cell","maxX","setChildHeights","getColumnWidth","_colspan","colspan","getEstimatedHeight","estimatedHeight","buildColumn","zIndex","empty","buildRow","buildCell","addVisibleLayoutInfos","firstVisibleRow","binarySearch","topLeft","lastVisibleRow","bottomRight","firstVisibleCell","lastVisibleCell","topRight","stickyIndex","idx","items","point","axis","low","high","mid"],"sources":["/Users/rai/Desktop/go-packing-project/node_modules/@react-stately/layout/dist/packages/@react-stately/layout/src/ListLayout.ts","/Users/rai/Desktop/go-packing-project/node_modules/@react-stately/layout/dist/packages/@react-stately/layout/src/TableLayout_DEPRECATED.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {InvalidationContext, Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\nimport {Key} from 'react';\n// import { DragTarget, DropTarget, DropPosition } from '@react-types/shared';\n\nexport type ListLayoutOptions<T> = {\n  /** The height of a row in px. */\n  rowHeight?: number,\n  estimatedRowHeight?: number,\n  headingHeight?: number,\n  estimatedHeadingHeight?: number,\n  padding?: number,\n  indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number,\n  collator?: Intl.Collator,\n  loaderHeight?: number,\n  placeholderHeight?: number,\n  allowDisabledKeyFocus?: boolean\n};\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  header?: LayoutInfo,\n  children?: LayoutNode[]\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a collection view {@link Layout}\n * it is used for creating lists and lists with indented sub-lists.\n *\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing collection view\n * delegate with an additional method to do this (it uses the same delegate object as\n * the collection view itself).\n */\nexport class ListLayout<T> extends Layout<Node<T>> implements KeyboardDelegate {\n  protected rowHeight: number;\n  protected estimatedRowHeight: number;\n  protected headingHeight: number;\n  protected estimatedHeadingHeight: number;\n  protected padding: number;\n  protected indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number;\n  protected layoutInfos: Map<Key, LayoutInfo>;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  collection: Collection<Node<T>>;\n  disabledKeys: Set<Key> = new Set();\n  allowDisabledKeyFocus: boolean = false;\n  isLoading: boolean;\n  protected lastWidth: number;\n  protected lastCollection: Collection<Node<T>>;\n  protected rootNodes: LayoutNode[];\n  protected collator: Intl.Collator;\n  protected invalidateEverything: boolean;\n  protected loaderHeight: number;\n  protected placeholderHeight: number;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions<T> = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.loaderHeight = options.loaderHeight;\n    this.placeholderHeight = options.placeholderHeight;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;\n  }\n\n  getLayoutInfo(key: Key) {\n    return this.layoutInfos.get(key);\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n          if (node.header) {\n            res.push(node.header);\n          }\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky;\n  }\n\n  validate(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    this.invalidateEverything = invalidationContext.sizeChanged;\n\n    this.collection = this.virtualizer.collection;\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!this.collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutInfos.delete(layoutNode.layoutInfo.key);\n            this.layoutInfos.delete(layoutNode.header?.key);\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n  }\n\n  buildCollection(): LayoutNode[] {\n    let y = this.padding;\n    let nodes = [];\n    for (let node of this.collection) {\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.loaderHeight ?? this.virtualizer.visibleRect.height);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n    }\n\n    if (nodes.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.placeholderHeight ?? this.virtualizer.visibleRect.height);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({layoutInfo: placeholder});\n      y = placeholder.rect.maxY;\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  buildChild(node: Node<T>, x: number, y: number): LayoutNode {\n    let cached = this.layoutNodes.get(node.key);\n    if (!this.invalidateEverything && cached && cached.node === node && y === (cached.header || cached.layoutInfo).rect.y) {\n      return cached;\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n\n    layoutNode.layoutInfo.parentKey = node.parentKey ?? null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n    if (layoutNode.header) {\n      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    }\n\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let children = [];\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n    }\n\n    rect.height = y - startY;\n\n    return {\n      header,\n      layoutInfo,\n      children\n    };\n  }\n\n  buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    if (typeof this.indentationForItem === 'function') {\n      x += this.indentationForItem(this.collection, node.key) || 0;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    // allow overflow so the focus ring/selection ring can extend outside to overlap with the adjacent items borders\n    layoutInfo.allowOverflow = true;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutInfo = this.layoutInfos.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutInfo) {\n      return false;\n    }\n\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo);\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by clearing node.\n      n.node = null;\n\n      // Replace layout info in LayoutNode\n      if (n.header === oldLayoutInfo) {\n        n.header = newLayoutInfo;\n      } else if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key: Key) {\n    let collection = this.collection;\n\n    key = collection.getKeyBefore(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let collection = this.collection;\n\n    key = collection.getKeyAfter(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key): Key {\n    return key;\n  }\n\n  getKeyRightOf(key: Key): Key {\n    return key;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y > pageY) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key) {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey() {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  // getDragTarget(point: Point): DragTarget {\n  //   let visible = this.getVisibleLayoutInfos(new Rect(point.x, point.y, 1, 1));\n  //   if (visible.length > 0) {\n  //     visible = visible.sort((a, b) => b.zIndex - a.zIndex);\n  //     return {\n  //       type: 'item',\n  //       key: visible[0].key\n  //     };\n  //   }\n\n  //   return null;\n  // }\n\n  // getDropTarget(point: Point): DropTarget {\n  //   let key = this.virtualizer.keyAtPoint(point);\n  //   if (key) {\n  //     return {\n  //       type: 'item',\n  //       key,\n  //       dropPosition: DropPosition.ON\n  //     };\n  //   }\n\n  //   return null;\n  // }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnProps, TableCollection} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\nimport {LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {LayoutNode, ListLayout, ListLayoutOptions} from './ListLayout';\n\n\ntype TableLayoutOptions<T> = ListLayoutOptions<T> & {\n  getDefaultWidth: (props) => string | number\n}\n\nexport class TableLayout_DEPRECATED<T> extends ListLayout<T> {\n  collection: TableCollection<T>;\n  lastCollection: TableCollection<T>;\n  columnWidths: Map<Key, number>;\n  stickyColumnIndices: number[];\n  getDefaultWidth: (props) => string | number;\n  wasLoading = false;\n  isLoading = false;\n\n  constructor(options: TableLayoutOptions<T>) {\n    super(options);\n    this.getDefaultWidth = options.getDefaultWidth;\n  }\n\n\n  buildCollection(): LayoutNode[] {\n    // If columns changed, clear layout cache.\n    if (\n      !this.lastCollection ||\n      this.collection.columns.length !== this.lastCollection.columns.length ||\n      this.collection.columns.some((c, i) => c.key !== this.lastCollection.columns[i].key)\n    ) {\n      // Invalidate everything in this layout pass. Will be reset in ListLayout on the next pass.\n      this.invalidateEverything = true;\n    }\n\n    // Track whether we were previously loading. This is used to adjust the animations of async loading vs inserts.\n    let loadingState = this.collection.body.props.loadingState;\n    this.wasLoading = this.isLoading;\n    this.isLoading = loadingState === 'loading' || loadingState === 'loadingMore';\n\n    this.buildColumnWidths();\n    let header = this.buildHeader();\n    let body = this.buildBody(0);\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [\n      header,\n      body\n    ];\n  }\n\n  buildColumnWidths() {\n    this.columnWidths = new Map();\n    this.stickyColumnIndices = [];\n\n    // Pass 1: set widths for all explicitly defined columns.\n    let remainingColumns = new Set<GridNode<T>>();\n    let remainingSpace = this.virtualizer.visibleRect.width;\n    for (let column of this.collection.columns) {\n      let props = column.props as ColumnProps<T>;\n      let width = props.width ?? this.getDefaultWidth(props);\n      if (width != null) {\n        let w = this.parseWidth(width);\n        this.columnWidths.set(column.key, w);\n        remainingSpace -= w;\n      } else {\n        remainingColumns.add(column);\n      }\n\n      // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n      if (column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    }\n\n    // Pass 2: if there are remaining columns, then distribute the remaining space evenly.\n    if (remainingColumns.size > 0) {\n      let columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n\n      for (let column of remainingColumns) {\n        let props = column.props as ColumnProps<T>;\n        let minWidth = props.minWidth != null ? this.parseWidth(props.minWidth) : 75;\n        let maxWidth = props.maxWidth != null ? this.parseWidth(props.maxWidth) : Infinity;\n        let width = Math.floor(Math.max(minWidth, Math.min(maxWidth, columnWidth)));\n\n        this.columnWidths.set(column.key, width);\n        remainingSpace -= width;\n        if (width !== columnWidth) {\n          columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n        }\n      }\n    }\n  }\n\n  parseWidth(width: number | string): number {\n    if (typeof width === 'string') {\n      let match = width.match(/^(\\d+)%$/);\n      if (!match) {\n        throw new Error('Only percentages are supported as column widths');\n      }\n\n      return this.virtualizer.visibleRect.width * (parseInt(match[1], 10) / 100);\n    }\n\n    return width;\n  }\n\n  buildHeader(): LayoutNode {\n    let rect = new Rect(0, 0, 0, 0);\n    let layoutInfo = new LayoutInfo('header', 'header', rect);\n\n    let y = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let headerRow of this.collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y);\n      layoutNode.layoutInfo.parentKey = 'header';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n\n    this.layoutInfos.set('header', layoutInfo);\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildHeaderRow(headerRow: GridNode<T>, x: number, y: number) {\n    let rect = new Rect(0, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n\n    let height = 0;\n    let columns: LayoutNode[] = [];\n    for (let cell of headerRow.childNodes) {\n      let layoutNode = this.buildChild(cell, x, y);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      columns.push(layoutNode);\n    }\n\n    this.setChildHeights(columns, height);\n\n    rect.height = height;\n    rect.width = x;\n\n    return {\n      layoutInfo: row,\n      children: columns\n    };\n  }\n\n  setChildHeights(children: LayoutNode[], height: number) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  getColumnWidth(node: GridNode<T>) {\n    let colspan = node.colspan ?? 1;\n    let width = 0;\n    for (let i = 0; i < colspan; i++) {\n      let column = this.collection.columns[node.index + i];\n      width += this.columnWidths.get(column.key);\n    }\n\n    return width;\n  }\n\n  getEstimatedHeight(node: GridNode<T>, width: number, height: number, estimatedHeight: number) {\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = curNode !== lastNode || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight;\n        isEstimated = true;\n      }\n    }\n\n    return {height, isEstimated};\n  }\n\n  buildColumn(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = node.props?.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo\n    };\n  }\n\n  buildBody(y: number): LayoutNode {\n    let rect = new Rect(0, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', 'body', rect);\n\n    let startY = y;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let node of this.collection.body.childNodes) {\n      let layoutNode = this.buildChild(node, 0, y);\n      layoutNode.layoutInfo.parentKey = 'body';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, width || this.virtualizer.visibleRect.width, children.length === 0 ? this.virtualizer.visibleRect.height : 60);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      loader.parentKey = 'body';\n      loader.isSticky = children.length === 0;\n      this.layoutInfos.set('loader', loader);\n      children.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n      width = Math.max(width, rect.width);\n    } else if (children.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, this.virtualizer.visibleRect.height);\n      let empty = new LayoutInfo('empty', 'empty', rect);\n      empty.parentKey = 'body';\n      empty.isSticky = true;\n      this.layoutInfos.set('empty', empty);\n      children.push({layoutInfo: empty});\n      y = empty.rect.maxY;\n      width = Math.max(width, rect.width);\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n\n    this.layoutInfos.set('body', layoutInfo);\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildNode(node: GridNode<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  buildRow(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n\n    let children: LayoutNode[] = [];\n    let height = 0;\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      children.push(layoutNode);\n    }\n\n    this.setChildHeights(children, height);\n\n    rect.width = x;\n    rect.height = height + 1; // +1 for bottom border\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildCell(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = node.props?.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo\n    };\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    let res: LayoutInfo[] = [];\n\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  addVisibleLayoutInfos(res: LayoutInfo[], node: LayoutNode, rect: Rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header': {\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      }\n      case 'rowgroup': {\n        let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n        let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n        for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n          res.push(node.children[i].layoutInfo);\n          this.addVisibleLayoutInfos(res, node.children[i], rect);\n        }\n        break;\n      }\n      case 'headerrow':\n      case 'row': {\n        let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n        let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n        let stickyIndex = 0;\n        for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n          // Sticky columns and row headers are always in the DOM. Interleave these\n          // with the visible range so that they are in the right order.\n          if (stickyIndex < this.stickyColumnIndices.length) {\n            let idx = this.stickyColumnIndices[stickyIndex];\n            while (idx < i) {\n              res.push(node.children[idx].layoutInfo);\n              idx = this.stickyColumnIndices[stickyIndex++];\n            }\n          }\n\n          res.push(node.children[i].layoutInfo);\n        }\n\n        while (stickyIndex < this.stickyColumnIndices.length) {\n          let idx = this.stickyColumnIndices[stickyIndex++];\n          res.push(node.children[idx].layoutInfo);\n        }\n        break;\n      }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  binarySearch(items: LayoutNode[], point: Point, axis: 'x' | 'y') {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      let item = items[mid];\n\n      if ((axis === 'x' && item.layoutInfo.rect.maxX < point.x) || (axis === 'y' && item.layoutInfo.rect.maxY < point.y)) {\n        low = mid + 1;\n      } else if ((axis === 'x' && item.layoutInfo.rect.x > point.x) || (axis === 'y' && item.layoutInfo.rect.y > point.y)) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    let res = super.getInitialLayoutInfo(layoutInfo);\n\n    // If this insert was the result of async loading, remove the zoom effect and just keep the fade in.\n    if (this.wasLoading) {\n      res.transform = null;\n    }\n\n    return res;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}